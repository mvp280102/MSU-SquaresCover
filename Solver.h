#pragma once

#include <ctime>
#include <vector>
using namespace std;


// Точка на плоскости.
struct Point
{
	double x;                                           // Координата x.
	double y;                                           // Координата y.
};

// Квадрат на плоскости.
struct Square
{
	bool covered = false;                               // Флаг покрытия квадрата точкой.
	Point corner{};                                     // Координаты левого нижнего угла.
};

// Отрезок на прямой.
struct Segment
{
	double begin;                                       // Координата начала.
	double end;                                         // Координата конца.
};

// Данные для задачи.
struct TaskData
{
	bool error_conclude = false;                        // Флаг необходимости вычисления ошибки.
	unsigned int area_range;                            // Размер части плоскости.
	unsigned int side_length;                           // Длина стороны одного квадрата.
	vector<Square> squares;                             // Квадраты.
};

// Результаты решения задачи.
struct TaskResults
{
	double total_time;                                  // Время, затраченное на решение.
	double step_time;                                   // Среднее время, затраченное на один шаг решения.
	unsigned long int steps;                            // Количество шагов в решении.
	unsigned long int error;                            // Ошибка решения.
	vector<Point> points;                               // Точки покрытия.
};


// Класс, решающий задачу.
class Solver
{
	private:

	TaskData data{};                                    // Данные для задачи.
	TaskResults results{};                              // Результаты решения задачи.
	vector< vector < vector<unsigned int> > > areas;    // Разбиение части плоскости на клетки.


	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Если точка принадлежит квадрату, возвращает true, иначе - false.
	 *
	 * ПАРАМЕТРЫ:
	 * Point &point - точка
	 * Square &square - квадрат
	 */
	[[nodiscard]] bool belong(const Point &point, const Square &square) const;

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Если квадраты пересекаются, возвращает указатель на
	 * координаты середины их пересечения, иначе - nullptr.
	 *
	 * ПАРАМЕТРЫ:
	 * unsigned int first - номер первого квадрата
	 * unsigned int second - номер второго квадрата
	 */
	Point* middle(unsigned int first, unsigned int second);

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Определяет, пересекаются ли отрезки.
	 * Если первый пересекается со вторым слева, возвращает -1.
	 * Если первый пересекается со вторым справа, возвращает 1.
	 * Если первый полностью лежит во втором, возвращает 2.
	 * Во всех остальных случаях возвращает 0.
	 *
	 * ПАРАМЕТРЫ:
	 * const Segment &first - первый отрезок
	 * const Segment &second - второй отрезок
	 */
	static int intersection(const Segment &first, const Segment &second);

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Общая часть первоначальной и усовершенствованной версий жадного алгоритма.
	 *
	 * АЛГОРИТМ:
	 * Под шагом понимается анализ пары квадратов на предмет их пересечения.
	 * На каждом шаге из заданного диапазона выбирается первый непокрытый квадрат.
	 * Он считается начальным пересечением. Затем для каждого следующего в диапазоне
	 * непокрытого квадрата вычисляется его пересечение с пересечением, полученным
	 * на предыдущем шаге. Процесс прекращается, когда в диапазоне не остается квадратов,
	 * пересекающихся с уже полученным пересечением. Когда максимальное пересечение
	 * получено, точкой покрытия считается его середина, а все квадраты, вошедшие
	 * в максимальное пересечение, помечаются как покрытые. Алгоритм завершается,
	 * когда все квадраты из заданного диапазона покрыты точками.
	 *
	 * ПАРАМЕТРЫ:
	 * unsigned int size - диапазон
	 */
	void greedy_common(unsigned int size);

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Вычисляет ошибку для решения текущей задачи.
	 * Для покрытия квадрата достаточно одной точки.
	 * Под ошибкой понимается количество квадратов,
	 * покрытых более, чем одной точкой.
	 */
	unsigned long int error();


	public:

	/*
	 * КОНСТРУКТОР.
	 */
	explicit Solver(TaskData data) : data(move(data)) {}

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Решает задачу покрытия квадратов точками простым алгоритмом.
	 * Возвращает ссылку на структуру с результатами решения задачи.
	 *
	 * АЛГОРИТМ:
	 * Под шагом понимается анализ пары квадратов на предмет их пересечения, и
	 * вычисление координат середины этого пересечения в соответствующем случае.
	 * На каждом шаге все пары еще не покрытых квадратов сравниваются на предмет
	 * их пересечения. Если они пересекаются, точкой покрытия считается середина
	 * их пересечения, а квадраты помечаются как покрытые. Если какой-либо непокрытый
	 * квадрат не пересекается с другими непокрытыми, точка покрытия - его середина.
	 * Алгоритм завершается, когда все квадраты покрыты точками.
	 */
	TaskResults& cover_simple();

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Решает задачу покрытия квадратов точками первоначальным жадным алгоритмом.
	 * Возвращает ссылку на структуру с результатами решения задачи.
	 *
	 * АЛГОРИТМ:
	 * В качестве диапазона для общей части жадных алгоритмов использует всю плоскость.
	 * Запускает общую часть жадных алгоритмов на данном диапазоне.
	 */
	TaskResults& cover_greedy_elementary();

	/*
	 * ОПИСАНИЕ ФУНКЦИИ:
	 * Решает задачу покрытия квадратов точками усовершенствованным жадным алгоритмом.
	 * Возвращает ссылку на структуру с результатами решения задачи.
	 *
	 * АЛГОРИТМ:
	 * Предварительно разбивает всю плоскость на квадратные клетки с длиной стороны,
	 * равной удвоенной длине стороны квадрата. В качестве диапазона для общей части
	 * жадных алгоритмов использует каждую клетку. Запускает общую часть жадных
	 * алгоритмов на каждом из таких диапазонов.
	 */
	TaskResults& cover_greedy_improved();
};
